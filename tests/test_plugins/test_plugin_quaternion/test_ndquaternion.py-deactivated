import numpy as np
import pytest
from quaternion import as_float_array, as_quat_array
from numpy import quaternion

from spectrochempy.plugins.quaternion.core.dataset.baseobjects.ndquaternion import (
    NDQuaternionArray,
)
from spectrochempy.core.units import ur
from spectrochempy.utils.testing import assert_array_equal, assert_approx_equal

typequaternion = np.dtype(np.quaternion)


def test_ndquaternion_init_with_array():
    d = np.arange(24).reshape(3, 2, 4)
    d = as_quat_array(d)
    d0 = NDQuaternionArray(d)

    assert d0.shape == (3, 2)
    assert_array_equal(d0.real.data, [[0, 4], [8, 12], [16, 20]])

    d1 = NDQuaternionArray(d)
    d1 = d1.set_quaternion()
    assert_array_equal(d1.real.data, [[0, 4], [8, 12], [16, 20]])


def test_ndquaternion_swapdims():
    d = np.arange(24).reshape(3, 2, 4)
    d = as_quat_array(d)
    d0 = NDQuaternionArray(d)

    d1 = d0.swapdims(1, 0)
    assert d1.shape == (2, 3)
    assert_array_equal(d1.real.data, [[0, 8, 16], [4, 12, 20]])
    assert d1[0, 0].values == quaternion(0, 2, 1, 3)


def test_ndquaternion_init_with_complex():
    np.random.seed(12345)
    d = np.random.random((4, 3)) * np.exp(0.1j)
    d0 = NDQuaternionArray(
        d,
        units=ur.Hz,
        mask=[[False, True, False], [True, False, False]],
        dtype=typequaternion,
    )
    assert d0.shape == (2, 3)
    assert "NDQuaternionArray: [quaternion] Hz" in repr(d0)


def test_ndquaternion_validation():
    # Test odd number of columns
    d = np.random.random((3, 3)) * np.exp(0.1j)
    with pytest.raises(ValueError):
        NDQuaternionArray(d, dtype=typequaternion)

    # Test odd number of rows
    d = np.random.random((3, 4))
    with pytest.raises(ValueError):
        NDQuaternionArray(d, dtype=typequaternion)


def test_ndquaternion_component_access():
    np.random.seed(12345)
    d = np.random.random((4, 2)) * np.exp(0.1j)
    nd = NDQuaternionArray(d, dtype=typequaternion)

    assert nd.shape == (2, 2)

    # Test real component
    real = nd.real
    assert real.dtype == np.float64
    assert real.shape == (2, 2)

    # Test imaginary component
    imag = nd.imag
    assert imag.dtype == typequaternion


def test_ndquaternion_RR_RI_IR_II():
    np.random.seed(12345)
    d = np.random.random((4, 2)) * np.exp(0.1j)
    nd = NDQuaternionArray(d, dtype=typequaternion)

    # Test RR component
    rr = nd.RR
    assert rr.dtype == np.float64

    # Test RI component
    ri = nd.RI
    assert rr.dtype == np.float64

    # Test IR component
    ir = nd.IR
    assert rr.dtype == np.float64

    # Test II component
    ii = nd.II
    assert rr.dtype == np.float64


def test_ndquaternion_transpose():
    np.random.seed(12345)
    d = np.random.random((4, 3)) * np.exp(0.1j)
    nd = NDQuaternionArray(d, dtype=typequaternion)

    trans = nd.transpose()
    assert trans.shape == (3, 2)
    assert trans.is_quaternion

    # Check components are properly transposed
    w, x, y, z = as_float_array(nd.data).T
    wt, yt, xt, zt = as_float_array(trans.data).T
    assert_array_equal(xt, x.T)
    assert_array_equal(yt, y.T)
    assert_array_equal(zt, z.T)
    assert_array_equal(wt, w.T)


def test_ndquaternion_slicing():
    np.random.seed(12345)
    d = np.random.random((4, 2)) * np.exp(0.1j)
    nd = NDQuaternionArray(d, dtype=typequaternion, units=ur.meter)

    # Test single element access
    elem = nd[1, 1].real
    assert_approx_equal(elem.values.magnitude, 0.59256946007362, 3)

    # Test slicing
    slice1 = nd[0:2, 1]
    assert slice1.shape == (2, 1)
    assert slice1.is_quaternion

# ======================================================================================
# Quaternion NDDataset tests
# ======================================================================================
IS_QUATERNION = hasattr(np, "quaternion")
typequaternion = np.dtype(np.quaternion) if IS_QUATERNION else None


@pytest.mark.skipif(not IS_QUATERNION, reason="quaternion plugin not installed")
def test_nddataset_create_quaternion():
    nd = scp.NDDataset(
        [
            [1.0, 2.0],
            [1.3, 2.0],
            [1.0, 2.0],
            [1.0, 2.0],
        ],
        dtype=typequaternion,
    )
    assert nd.data.size == 2
    assert nd.size == 2
    assert nd.data.shape == (2, 1)
    assert nd.shape == (2, 1)
    assert nd.is_quaternion


@pytest.mark.skipif(not IS_QUATERNION, reason="quaternion plugin not installed")
def test_nddataset_quaternion_operations():
    na0 = np.array(
        [
            [1.0, 2.0, 2.0, 0.0, 0.0, 0.0],
            [1.3, 2.0, 2.0, 0.5, 1.0, 1.0],
            [1, 4.2, 2.0, 3.0, 2.0, 2.0],
            [5.0, 4.2, 2.0, 3.0, 3.0, 3.0],
        ]
    )
    nd = scp.NDDataset(na0)
    nd.set_quaternion()
    assert nd.is_quaternion

    # Test quaternion-specific operations
    nds = nd.swapdims(0, 1)
    assert_array_equal(nd.data.T, nds.data)
    assert nd.coordset[0] == nds.coordset[0]


@pytest.mark.skipif(not IS_QUATERNION, reason="quaternion plugin not installed")
def test_nddataset_quaternion_real_imag():
    na = np.array(
        [
            [1.0 + 2.0j, 2.0 + 0j],
            [1.3 + 2.0j, 2.0 + 0.5j],
            [1.0 + 4.2j, 2.0 + 3j],
            [5.0 + 4.2j, 2.0 + 3j],
        ]
    )
    nd = scp.NDDataset(na)
    nd.set_quaternion(inplace=True)
    assert nd.is_quaternion
    assert_array_equal(nd.real.data, na[::2, :].real)


@pytest.mark.skipif(not IS_QUATERNION, reason="quaternion plugin not installed")
def test_nddataset_quaternion_rotation():
    na0 = np.array([[1.0, 0.0, 0.0, 0.0], [0.0, 1.0, 0.0, 0.0]])
    nd = scp.NDDataset(na0)
    nd.set_quaternion()

    # Test basic quaternion operations
    nds = nd.conjugate()
    assert nds.is_quaternion
    assert_array_equal(nds.data[0], [1.0, 0.0, 0.0, 0.0])


@pytest.mark.skipif(not IS_QUATERNION, reason="quaternion plugin not installed")
def test_nddataset_quaternion_conversion():
    na0 = np.array([[1.0, 0.0, 0.0, 0.0], [0.0, 1.0, 0.0, 0.0]])
    nd = scp.NDDataset(na0, dtype=np.quaternion)

    # Test conversion to/from quaternion
    nd_float = nd.to_float()
    assert not nd_float.is_quaternion
    assert nd_float.shape == (2, 4)

    nd_quat = nd_float.to_quaternion()
    assert nd_quat.is_quaternion
    assert nd_quat.shape == (2, 1)

@pytest.mark.skipif(not IS_QUATERNION, reason="quaternion plugin not installed")
def test_nddataset_max_with_2D_quaternion(NMR_dataset_2D):
    # test on a 2D NDDataset
    nd2 = NMR_dataset_2D
    assert nd2.is_quaternion
    nd = nd2.RR
    nd.max()
    nd2.max()  # no axis specified
    nd2.max(dim=0)  # axis selected


@pytest.mark.skipif(not IS_QUATERNION, reason="quaternion plugin not installed")
def test_nddataset_max_min_with_1D(NMR_dataset_1D):
    # test on a 1D NDDataset
    nd1 = NMR_dataset_1D
    nd1[4] = scp.MASKED
    assert nd1.is_masked
    mx = nd1.max().m
    assert (mx.real, mx.imag) == pytest.approx((2283.5096153847107, -2200.383064516033))
    # check if it works for real
    mx1 = nd1.real.max().m
    assert mx1 == pytest.approx(2283.5096153847107)
    mi = nd1.min().m
    assert (mi.real, mi.imag) == pytest.approx((-408.29714640199626, 261.1864143920416))


@pytest.mark.skipif(not IS_QUATERNION, reason="quaternion plugin not installed")
def test_nddataset_comparison_of_dataset(NMR_dataset_1D):
    # bug in notebook
    nd1 = NMR_dataset_1D.copy()
    nd2 = NMR_dataset_1D.copy()
    lb1 = nd1.em(lb=100.0 * ur.Hz)
    lb2 = nd2.em(lb=100.0 * ur.Hz)
    assert nd1 is not nd2
    assert nd1 == nd2
    assert lb1 is not lb2
    assert lb1 == lb2
